// Intervention Planning Module - Plans Hook
// Manages CRUD operations for intervention plans

import { useState, useEffect } from 'react';
import { supabase } from '../lib/supabase';
import type { InterventionPlan, PlanFormData } from '../types/plan';
import { useAuth } from '../context/AuthContext';
import { calculatePlanStats } from '../lib/planUtils';

// Multi-tenant installation selection is implemented via useAuth hook


export interface UsePlansReturn {
    plans: InterventionPlan[];
    loading: boolean;
    error: string | null;
    refetch: () => Promise<void>;
    createPlan: (data: PlanFormData) => Promise<InterventionPlan | null>;
    updatePlan: (id: string, data: Partial<PlanFormData>) => Promise<InterventionPlan | null>;
    deletePlan: (id: string) => Promise<boolean>;
    getPlanById: (id: string) => Promise<InterventionPlan | null>;
}

/**
 * Hook to manage intervention plans with Supabase
 */
export function usePlans(): UsePlansReturn {
    const { activeInstallation } = useAuth(); // Get activeInstallation from context
    const [plans, setPlans] = useState<InterventionPlan[]>([]);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState<string | null>(null);

    /**
     * Fetch all plans for the current installation
     */
    const fetchPlans = async () => {
        if (!activeInstallation?.id) {
            setPlans([]);
            setLoading(false);
            return;
        }

        try {
            setLoading(true);
            setError(null);

            const { data, error: fetchError } = await supabase
                .from('intervention_plans')
                .select('*, tree:arvores(id, especie, local, risklevel), work_orders(id, status, tasks(progress_percent))')
                .eq('instalacao_id', activeInstallation.id) // Use activeInstallation.id
                .order('created_at', { ascending: false });

            if (fetchError) throw fetchError;

            setPlans(data as any || []); // Type cast due to joined data
        } catch (err) {
            console.error('Error fetching plans:', err);
            setError(err instanceof Error ? err.message : 'Erro ao carregar planos');
            setPlans([]);
        } finally {
            setLoading(false);
        }
    };

    /**
     * Create a new intervention plan
     */
    const createPlan = async (formData: PlanFormData): Promise<InterventionPlan | null> => {
        if (!activeInstallation?.id) {
            setError('Nenhuma instalação selecionada');
            return null;
        }

        try {
            setError(null);

            const { data: { user } } = await supabase.auth.getUser();
            if (!user) throw new Error('Usuário não autenticado');

            // plan_id will be auto-generated by the database trigger
            const newPlan = {
                instalacao_id: activeInstallation.id,
                user_id: user.id,
                intervention_type: formData.intervention_type,
                tree_id: formData.tree_id, // Add tree_id
                schedule: formData.schedule,
                justification: formData.justification || null,
                responsible: formData.responsible || null,
                responsible_title: formData.responsible_title || null,
                techniques: formData.techniques || [],
                tools: formData.tools || [],
                epis: formData.epis || [],
                team_composition: formData.team_composition || null,
                durations: formData.durations || null,
            };

            const { data, error: insertError } = await supabase
                .from('intervention_plans')
                .insert(newPlan)
                .select('*, tree:arvores(id, especie, codigo, local)')
                .single();

            if (insertError) throw insertError;

            // Update local state
            setPlans(prev => [data as any, ...prev]);

            return data as any;
        } catch (err) {
            console.error('Error creating plan:', err);
            setError(err instanceof Error ? err.message : 'Erro ao criar plano');
            return null;
        }
    };

    /**
     * Update an existing intervention plan
     */
    const updatePlan = async (
        id: string,
        formData: Partial<PlanFormData>
    ): Promise<InterventionPlan | null> => {
        try {
            setError(null);

            const { data, error: updateError } = await supabase
                .from('intervention_plans')
                .update(formData)
                .eq('id', id)
                .select('*, tree:arvores(id, especie, codigo, local)')
                .single();

            if (updateError) throw updateError;

            // Update local state
            setPlans(prev => prev.map(p => p.id === id ? data as any : p));

            return data as any;
        } catch (err) {
            console.error('Error updating plan:', err);
            setError(err instanceof Error ? err.message : 'Erro ao atualizar plano');
            return null;
        }
    };

    /**
     * Delete an intervention plan
     */
    const deletePlan = async (id: string): Promise<boolean> => {
        try {
            setError(null);

            const { error: deleteError } = await supabase
                .from('intervention_plans')
                .delete()
                .eq('id', id);

            if (deleteError) throw deleteError;

            // Update local state
            setPlans(prev => prev.filter(p => p.id !== id));

            return true;
        } catch (err) {
            console.error('Error deleting plan:', err);
            setError(err instanceof Error ? err.message : 'Erro ao excluir plano');
            return false;
        }
    };

    /**
     * Get a single plan by ID
     */
    const getPlanById = async (id: string): Promise<InterventionPlan | null> => {
        try {
            setError(null);

            const { data, error: fetchError } = await supabase
                .from('intervention_plans')
                .select('*, tree:arvores(id, especie, codigo, local)')
                .eq('id', id)
                .single();

            if (fetchError) throw fetchError;

            return data as any;
        } catch (err) {
            console.error('Error fetching plan:', err);
            setError(err instanceof Error ? err.message : 'Erro ao carregar plano');
            return null;
        }
    };

    // Fetch plans when installation changes
    useEffect(() => {
        if (activeInstallation?.id) {
            fetchPlans();
        }
    }, [activeInstallation?.id]);

    return {
        plans,
        loading,
        error,
        refetch: fetchPlans,
        createPlan,
        updatePlan,
        deletePlan,
        getPlanById
    };
}

/**
 * Hook to calculate plan statistics
 */
export function usePlanStats(plans: InterventionPlan[]) {
    const [stats, setStats] = useState<ReturnType<typeof calculatePlanStats>>({
        totalPlans: 0,
        pendingInterventions: 0,
        thisWeek: 0,
        thisMonth: 0,
        byType: {
            poda: 0,
            supressao: 0,
            transplante: 0,
            tratamento: 0,
            monitoramento: 0
        }
    });

    useEffect(() => {
        setStats(calculatePlanStats(plans));
    }, [plans]);

    return stats;
}
