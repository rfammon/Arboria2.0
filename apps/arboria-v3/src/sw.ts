/// <reference lib="webworker" />

import { precacheAndRoute } from 'workbox-precaching';
import { openDB, type IDBPDatabase } from 'idb';

declare const self: ServiceWorkerGlobalScope;

// Precache all assets generated by the build process
precacheAndRoute(self.__WB_MANIFEST);

// DB Configuration (Duplicated for SW independence)
const DB_NAME = 'arboria-media-cache';
const STORE_NAME = 'photos';
const DB_VERSION = 1;

let dbPromise: Promise<IDBPDatabase> | null = null;

function getDB() {
    if (!dbPromise) {
        dbPromise = openDB(DB_NAME, DB_VERSION, {
            upgrade(db) {
                if (!db.objectStoreNames.contains(STORE_NAME)) {
                    db.createObjectStore(STORE_NAME, { keyPath: 'url' });
                }
            },
        });
    }
    return dbPromise;
}

// Supabase Storage URL Pattern (Adjust base on your actual project ID)
const SUPABASE_STORAGE_URL = 'https://ovhhtnsvlyclqofixrvy.supabase.co/storage/v1/object/public/tree-photos';

/**
 * Service Worker: Offline Photo Caching
 * ------------------------------------
 * Intercepts requests to the Supabase storage and caches them in IndexedDB.
 */
self.addEventListener('fetch', (event) => {
    const url = event.request.url;

    if (url.startsWith(SUPABASE_STORAGE_URL)) {
        event.respondWith(
            (async () => {
                try {
                    // 1. Check IndexedDB
                    const db = await getDB();
                    const cached = await db.get(STORE_NAME, url);

                    if (cached && cached.blob) {
                        console.log('[SW] Serving from IDB:', url);
                        return new Response(cached.blob, {
                            headers: { 'Content-Type': cached.contentType || 'image/jpeg' }
                        });
                    }

                    // 2. Fetch from Network
                    console.log('[SW] Fetching from network:', url);
                    const networkResponse = await fetch(event.request);

                    if (networkResponse.status === 200) {
                        // 3. Save to IDB for future offline use
                        const blob = await networkResponse.clone().blob();
                        await db.put(STORE_NAME, {
                            url,
                            blob,
                            contentType: networkResponse.headers.get('Content-Type') || 'image/jpeg',
                            timestamp: Date.now()
                        });
                    }

                    return networkResponse;
                } catch (error) {
                    console.error('[SW] Cache/Fetch failed:', url, error);
                    return new Response('Offline and not cached', { status: 503 });
                }
            })()
        );
    }
});

// Allow the SW to take control immediately
self.addEventListener('install', () => self.skipWaiting());
self.addEventListener('activate', (event) => event.waitUntil(self.clients.claim()));
